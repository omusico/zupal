package game{	import flash.geom.Point;	import flash.utils.Dictionary;	import de.polygonal.ds.*;	import game.synerg.tiles.Tile_abstract;	import game.synerg.beings.Being_abstract;	/*	The Point_ij is intended to reflect a grid point on the game board.	It is oriented towards pathfinding and registering blocks. 	It is possible to create "one way blocks"  as in, doors with locks on one side or cliffs. 		board points are kept in a 2d array -- to retrieve board points, use the static point(i,j) method. 	You can create a point that is not on the board thorugh this method but an "unregistered" point will be created. 		Note -- because a point is a shared coordinate, its ij values cannot be changed	once they are set. they map to locals x and y and are set by the inherited constructor. 	*/	public class Point_ij extends Point {		public function Point_ij(pi, pj) {			super(pi, pj);		}		/* **************** I, J Coordinates **************** */		public function get i():int {			return x;		}		public function get j():int {			return y;		}		/* *************** X, Y Coordinates ******************/		/*		 * This point is the visual location of the sprite. 		 * Because the 		*/		private var _point:Point=null;		public function get xy_point() {			if (! _point) {				_point=new Point(i*Synerg.BOARD_RES,j*Synerg.BOARD_RES);			}			return _point;		}		/* **************** POINT REGISTRY ******************** */		private static var _points:Array2;		private static function _init_points() {			var iter=0;			_points=new Array2(Synerg.BOARD_SIZE,Synerg.BOARD_SIZE);			for (var i_iter = 0; i_iter < Synerg.BOARD_SIZE; ++i_iter) {				for (var j_iter = 0; j_iter < Synerg.BOARD_SIZE; ++j_iter) {					var pt:Point_ij=new Point_ij(i_iter,j_iter);					_points.set(i_iter, j_iter, pt);				}			}		}		public static function get points():Array2 {			if (! _points) {				_init_points();			}			return _points;		}		public static function point(i: int, j: int, spawn_off_board: Boolean = false):Point_ij {			if (! Synerg.on_board(i,j)) {				return spawn_off_board ? new Point_ij(i, j) : null;			} else {				return points.get(i, j);			}		}		public function ijadd(p: Point_ij, spawn_point = false):Point_ij {			var s_i=i+p.i;			var s_j=j+p.j;			return point(s_i,s_j, spawn_point);		}		/* *********** BLOCKING ************** */		private var _blocks:Vector.<Move_block>=Vector.<Move_block>([]);		public function add_block(b: Move_block) {			_blocks.push(b);		}		public function can_go(from_point: Point_ij, being: Being_abstract) {			//trace("checking travel from " + from_point + " to " + this);			for (var iter = 0; iter < _blocks.length; ++iter) {				var block:Move_block=_blocks[iter];				if (				(block.block_mode==Move_block.MODE_ENTER) && 				 (!being.ignore_block(block))				 ) {					return false;				} else {					//trace("checking block vector from " + from_point + " to " + this + ": block = " + block);					if (					block.block_from(from_point) && 					(!being.ignore_block(block))					) {						return false;					}				}			}			return true;		}		/*		 * Returns the list of possible points that can be reached from this one. 		 * @TODO: cache 		 */		public function can_go_points(b: Being_abstract):Vector.<Point_ij> {			var out=Vector.<Point_ij>([]);			for (var compass_angle = 0; compass_angle < 8; compass_angle += 2) {				// note -- incrementing by 2 restricts us to NSEW points				var c_point=point_at_compass_angle(compass_angle);				if (c_point) {					if (c_point.can_go(this,b)) {						out.push(c_point);					} else {						trace(b + " cannot go to " + c_point);					}				}			}			return out;		}		/* ************ BLOCK BETWEEN,  TILE ******************** */		public static function block_out_tile(t: Tile_abstract) {			var p:Point_ij=t.point;			for (var i_iter = 0; i_iter < t.piece_width(); ++i_iter) {				for (var j_iter = 0; j_iter < t.piece_height(); ++j_iter) {					var tp=point(p.i+i_iter,p.j+j_iter);					var b:Move_block=new Move_block(t,tp,Move_block.MODE_ENTER,null);					// creating the block adds it to the target point automatically.				}			}		}		/**		creates a two-way barrier between transportation 		        from one point to another. 		Because this barrier only exists between ADJACENT points 		you MUST always call can_go between adjacent points. 		*/		public static function block_between(block_source, p1: Point_ij, p2: Point_ij) {			var b:Move_block=new Move_block(block_source,p1,Move_block.MODE_VECTOR,Vector.<Point_ij>([p2]));			var b2:Move_block=new Move_block(block_source,p2,Move_block.MODE_VECTOR,Vector.<Point_ij>([p1]));		}		/* ************* ANGLES, COMPASS AND VECTOR CONSTANTS ***********/		/* 		returns the angle to the passed point. 		*/		public function point_to_angle(p: Point_ij, as_compass: Boolean = false):Number {			var dx=p.x-i;			var dy=p.y-j;			var dist=Point.distance(this,p);			if (! dist) {				return 0;			}			var angle=Math.acos(dx/dist);			if (dy<0) {				angle=2*Math.PI-angle;			}//@TODO: cache in HashMap			var angle_degree=angle*180/Math.PI;			if (as_compass) {				var compass_angle=int(ANGLE_TO_COMPASS*angle)%8;				return compass_angle;			}			return angle;		}		public function point_at_compass_angle(compass_angle: uint, spawn_point = false) {			return ijadd(COMPASS_OFFSETS[compass_angle], spawn_point);		}		static var ANGLE_TO_COMPASS=4/Math.PI;		static var COMPASS_E=0;		static var COMPASS_SE=1;		static var COMPASS_S=2;		static var COMPASS_SW=3;		static var COMPASS_W=4;		static var COMPASS_NW=5;		static var COMPASS_N=6;		static var COMPASS_NE=7;		private static var _COMPASS_OFFSETS:Vector.<Point_ij>;		public static function get COMPASS_OFFSETS():Vector.<Point_ij> {			if ((! _COMPASS_OFFSETS) || (!_COMPASS_OFFSETS.length)) {				_COMPASS_OFFSETS =  Vector.<Point_ij>([				 new Point_ij(1, 0), new Point_ij(1, 1), 				 new Point_ij(0, 1), new Point_ij(-1, 1), 				 new Point_ij (-1, 0), new Point_ij (-1, -1),				 new Point_ij(0, -1), new Point_ij(1, -1)				 ]);			}			return _COMPASS_OFFSETS;		}		private var beings:Array=[];		/*		note -- add_being(b) will call remove_being(b); 		however, the reverse is not true. 		*/		public function add_being(b: Being_abstract) {			if (b.point) {				b.point.remove_being(b);			}			var l=beings.length;			for (var iter = 0; iter < l; ++iter) {				if (beings[iter]===b) {					//trace(b + " already in " + this);					return;				}			}			beings.push(b);		}		public function remove_being(b: Being_abstract) {			var new_beings:Array=[];			var l=beings.length;			for (var iter = 0; iter < l; ++iter) {				if (!(beings[iter] === b) ) {					new_beings.push(beings[iter]);				}			}			beings=new_beings;		}	}}