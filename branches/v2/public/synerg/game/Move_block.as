package game{	import game.Point_ij;	public class Move_block {		// Constants:		// Public Properties:		public function get vectors() {			return _vectors;		}		public var block_mode;		public var point:Point_ij;		public var source;		// Private Properties:		private var _vectors:Vector.<Point_ij>;		// Initialization:		public function Move_block(s, p: Point_ij, m: int, v: Vector.<Point_ij>) {			point=p;			block_mode=m;			_vectors=v;			p.add_block(this);			if (m == MODE_VECTOR){				trace("created block between " + p + " and " + v.join(','));			}		}		// Public Methods:		public function block_from(p: Point_ij){			if (vectors.length < 1) {				trace('!! BLOCK FROM VECTOR CHECKING EMPTY VECTOR LIST !!');				return;			}			for (var iter = 0; iter < vectors.length; ++iter){				var from_point: Point_ij = vectors[iter];				//trace('vector block checking from ' + point + ' to ' + from_point);				if (from_point.equals(p)) {					//trace("blocking travel from " + p + " to " + point);					return true; 				}			}			return false;		}						// Protected Methods:		public static var MODE_ENTER=0;		public static var MODE_VECTOR=1;				/* **************** TOSTRING ******************** */				public function toString(){			if (block_mode == MODE_VECTOR){				return "Move block between " + point + " and " + vectors.join(',');			} else {				return "Move block to " + point;			}		}	}}