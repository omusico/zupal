package game.synerg{	import game.synerg.tiles.Tile_abstract;	import game.synerg.beings.Being_abstract;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.display.*;	/*	this class tracks the position of elements of the same type	in the game to determine if they overlap. while there are flash	methods to detect overlaps, this uses integer positions in a grid (i x j)	to determine overlap on an abstract grid, rather than visual overlap,	because there may be cases where a tile visually overlaps another 	but is not intended to block placement. 	*/	public class Map {		public var name:String;		public function Map(pName:String) {			name=pName;		}		public function toString():String {			return 'Map ' + name + '(' + items().length + ' items)';		}		/* ************** TILES *************** */		private var _items: Array = new Array();		public function add_tile(t: Tile_abstract):void {			trace("adding " + t + " to " + this);			_items.push(t);		}		public function items():Array {			return _items;		}		/* *************** OVERLAPS *************** */		public function overlaps(t: Tile_abstract):Boolean {			//trace("map::overlaps(" + t + "); checking against " + _items.length + " tiles");			for (var iter = 0; iter < _items.length; ++iter) {				if (_items[iter].overlaps_with(t)) {					return true;				}			}			return false;		}		public function overlaps_point(p: Point) {			for (var iter = 0; iter < _items.length; ++iter) {				var r:Rectangle=_items[iter].rectangle();				if (r.containsPoint(p)) {					return true;				}			}			/*			var test = function(element:*, index:int, arr:Array){			if (element.rectangle().containsPoint(p)){			return true;			} else {			return false;			}			};*/			return false;		}		/* ************ EVENT MANAGEMENT ************ */		public function update(t: int) {			for (var i:int = 0; i < _items.length; ++i) {				var b=_items[i];				if (b is game.synerg.beings.Being_abstract) {					b.update(t);				}			}		}		/* ************* STACK MANAGEMENT ******************/		private var _layer:DisplayObjectContainer;		private function _get_layer():DisplayObjectContainer {			if (! _layer) {				if (! _items.length) {					return null;				}				_layer=_items[0].parent;			}			return _layer;		}		public function reshuffle() {			if (_items.length<2) {				//trace("not shuffling " + name);				return;			}			var l=_items[0].parent;			//trace("shuffling " + this);			do {				var swapped:Boolean = false;								for (var index:int = 1; index < l.numChildren; ++index) {					var c1=l.getChildAt(index-1);					var c2=l.getChildAt(index);					if (c1.y>c2.y) {						//trace('swapping ' + c1 + ' and ' + c2);						l.swapChildren(c1, c2);						swapped=true;					}				}			} while (swapped);		}	}}