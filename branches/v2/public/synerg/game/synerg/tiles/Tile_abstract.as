package game.synerg.tiles{	import flash.display.MovieClip;	import flash.events.Event;	import flash.ui.Mouse;	import flash.events.MouseEvent;	import Synerg;	import game.*;	import game.synerg.Map;	import flash.geom.Rectangle;	public class Tile_abstract extends MovieClip implements ID_element {		public var _i:uint=0;		public var _j:uint=0;		private var _rect:Rectangle;		private var _map:Map;		private var _id:uint;		public var clamp_loc:Boolean=false;		public var status:String="new";		/* @@@@@@@@@@@@@@@@ PROPERTIES @@@@@@@@@@@@@@@@@@@@@@@@@ */		/* ************** IDENTITY ********************/		public function piece_size():uint {			throw new Error("deprecated to piece-height, piece-width");		}		public function piece_width():uint {			throw new Error(this+" does not override piece_width()");		}		public function piece_height():uint {			throw new Error(this+" does not override piece_height()");		}		public function piece_type():String {			throw new Error("override piece type not implemented");		}		override public function toString():String {			return get_id() + ": " + piece_type() + " {" + rectangle() + "}";		}		public function set_id(id: uint) {			_id=id;		}		public function get_id():uint {			return _id;		}		/* **************** LOCATION POINT ***************** */		/*		note - setting i, j, or both will move the sprite! for an animated move		use the move function.		*/		private var _point:Point_ij;		public function get point():Point_ij {			if (! _point) {				_point=Point_ij.point(0,0);			}			return _point;		}		public function set point(p: Point_ij):void {			_point=p;			reset_position();		}		/*		reset_position aligns the position of the tile		with the values derived from the i,j coords		*/		private function reset_position() {			this.x=point.xy_point.x+nudge_x;			this.y=point.xy_point.y+nudge_y;			if (_rect) {				_rect.x = point.i;				_rect.y = point.j;			} else {				init_rect();			}		}		/*		places the piece randomly -- note only respects overlap on THIS map,		not any others. 		*/		public function random_position(max_iterations = 10) {			var iters=0;			if (max_iterations<10) {				max_iterations=10;			}			do {				var extent_i=Synerg.BOARD_SIZE-piece_width()+1;				var extent_j=Synerg.BOARD_SIZE-piece_height()+1;				var rand_i = (int) (Math.random() * extent_i);				var rand_j = (int) (Math.random() * extent_j);				//trace("trying to place " + this + " at " + rand_i + ", " + rand_j + "(iter " + iters + " of " + max_iterations + ")");				iters++;				point=Point_ij.point(rand_i,rand_j);			} while (overlaps() && (iters <= max_iterations));			return iters;		}		/* ************** NUDGES ************* */		/*		to avoid overlap, nudge is added to destination points 		keep nudges in +/- 5 range. 		*/		public var nudge_x=0;		public var nudge_y=0;		/* ********** PLACE, DRAG, OVERLAP ************* */		protected function overlaps():Boolean {			var m:Map=get_map();			return m.overlaps(this);// note -- might fail with self-overlap -- TODO: check. 		}		public function place():void {			if (overlaps()) {				parent.removeChild(this);				this.status="deleted";			} else {				var m:Map=get_map();				m.add_tile(this);				this.status="placed";			}		}		public function drag():void {			var rx=Math.max(0,parent.mouseX);			var ry=Math.max(0,parent.mouseY);			point = Point_ij.point(int(rx / Synerg.BOARD_RES), int(ry / Synerg.BOARD_RES));			this.status="dragging";		}		/*		This algorithm uses a useful fact; if on either dimension, the end of one extent		is less than the beginnign of another extent, or vice versa, the shapes do not overap.		*/		public function overlaps_with(t: Tile_abstract):Boolean {			//trace("checking overlap of " + this + " with " + t);			if (rectangle().intersects(t.rectangle())) {				//trace( "... ooo it DOES overlap! ");				return true;			} else {				return false;			}		}		/* ***************** RECT AND MAP ************** */		private function init_rect():void {			_rect=new Rectangle(point.i,point.j,piece_width(),piece_height());		}		public function rectangle():Rectangle {			if (! _rect) {				init_rect();			}			return _rect;		}		public function get_map():Map {			return _map;		}		public function set_map(m: Map):void {			_map=m;		}	}}