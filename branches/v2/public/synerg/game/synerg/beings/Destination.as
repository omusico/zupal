package game.synerg.beings{	import game.synerg.beings.Being_abstract;	import game.ID_element;	import flash.geom.Point;	import Synerg;	import game.synerg.tiles.*;		class Destination implements ID_element {		private var _id:uint=0;		public function Destination(i, j, speed, b: Being_abstract) {			set_being(b);			set_ij(i, j);			set_speed(speed);			set_id(++Destination._next_dest_id);			//trace("new Destionation: " + this);		}		public function toString() {			var out:String="Destination for "+get_being()+" to ij= "+get_i()+", "+get_j()+"; xy= "+x+", "+y;			return out;		}		/* ************** POINTS  ****************** */		private var _target_xy_point:Point=null;		public function target_xy_point() {			if (! _target_xy_point) {				_target_xy_point=new Point(x,y);			}			return _target_xy_point;		}				private var _target_ij_point:Point=null;		public function target_ij_point() {			if (! _target_ij_point) {				_target_ij_point=new Point(x,y);			}			return _target_ij_point;		}		/* ************** MOVEMENT  ****************** */				public function blocked(): Boolean{			var w: Array = Synerg.wall_map.items();			if (w.length < 1) return false;						var bpt:Point = get_being().as_ij_point();			var dpt:Point = target_ij_point();						for (var iter = 0; iter < w.length; ++iter){				var wall:Wall = w[iter];								if (wall.blocks(bpt, dpt)) {					trace("destination: wall " + wall + " blocked " + get_being() + " from " + bpt + " to " + dpt);					return true;				}							}			return false;		}		public function arrived():Boolean {			var b:Being_abstract=get_being();			var s:Number=get_speed();			var out:Boolean=is_about(b.x,x,s)&&is_about(b.y,y,s)?true:false;			return out;		}		public function move():void {			var b:Being_abstract=get_being();						if (arrived()) { // arrived notes approximate matches -- sync to exact target				b.x=x;				b.y=y;				b.end_move(this);			} else {				var bp:Point=get_being().as_xy_point();				var tp:Point=target_xy_point();				var d:Number=Point.distance(bp,tp);				var s:Number=get_speed();				var ir = get_i() ? (tp.x / (get_i())) : 0;				var jr = get_j() ? (tp.y / (get_j())) : 0;				//trace ("Destination::move() -- moving " + b + " towards " + tp);				//trace(tp + ": ir = " +  ir + ", jr = " + jr);				var ratio=Math.min(1, s/d);				var new_bp:Point=Point.interpolate(tp,bp,ratio);				//trace(" -- ratio: " + ratio + ", new point = " + new_bp);				b.x=new_bp.x;				b.y=new_bp.y;			}		}		/*		returns angle between the sprite and its destination point 		*/		public function motion_angle():Number {			var b=get_being();			var dx=x-b.x;			var dy=y-b.y;			if (dx) {				var tan=dy/dx;				return Math.atan(tan);			} else if (dy > 0) {				return Math.PI/2;			} else if (dy < 0) {				return (3 * Math.PI) / 2;			} else {				return 0;			}		}		private function is_about(a: Number, b: Number, slop: Number = 1):Boolean {			if (Math.abs(a-b)<=slop) {				return true;			} else {				return false;			}		}		/* ************** LOCATION  ****************** */		public function set_i(i: uint) {			var b:Being_abstract=get_being();			if (b&&b.clamp_loc) {				i=Synerg.clamp_i(i);			}			_i=i;			reset_target();		}		public function get_i():uint {			return _i;		}		public function set_j(j: uint) {			var b:Being_abstract=get_being();			if (b&&b.clamp_loc) {				j=Synerg.clamp_j(j);			}			_j=j;			reset_target();		}		public function get_j():uint {			return _j;		}		public function set_ij(i: uint, j: uint):void {			var b:Being_abstract=get_being();			//trace("Destination: set_ij(" + i + ", " + j + ")");			if (b&&b.clamp_loc) {				i=Synerg.clamp_i(i);				j=Synerg.clamp_j(j);				//trace("-- clamped to(" + i + ", " + j + ")");			}			_i=i;			_j=j;			reset_target();		}		private function reset_target() {			var b:Being_abstract=get_being();			//trace("reset_target ij = " + get_i() + ", " + get_j());			x=(int) (get_i()*Synerg.BOARD_RES + b.nudge_x);			y=(int) (get_j()*Synerg.BOARD_RES + b.nudge_y);			_target_xy_point=new Point(x,y);			_target_ij_point = new Point(get_i(), get_j());		}		private var _i:uint=0;		private var _j:uint=0;		public var x:Number=0;		public var y:Number=0;		private var _speed:Number=0;		private var _being:Being_abstract;		public function set_speed(n:Number):void {			var b:Being_abstract=get_being();			if (! b) {				throw new Error("destination::set_speed() -- no being for dest");			}			_speed=Math.max(0,Math.min(b.top_speed(),n));		}		public function get_speed():Number {			return _speed;		}		/* *************** BEING **************** */		public function set_being(b: Being_abstract) {			_being=b;		}		public function get_being() {			return _being;		}		public function get_id():uint {			return _id;		}		public function set_id(id: uint) {			_id=id;		}		private static var _next_dest_id:uint=0;	}}