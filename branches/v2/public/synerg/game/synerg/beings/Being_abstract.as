package game.synerg.beings{	import game.synerg.tiles.Tile_abstract;	import game.synerg.beings.Destination;	import flash.geom.Point;	import game.synerg.tiles.Wall;	import game.synerg.buttons.*;	import game.synerg.PointVector;	import game.*;	import flash.display.MovieClip;	import Synerg;	public class Being_abstract extends Tile_abstract {		public function update(t:int):void {			// override this to motivate beings ! 		}		override public function toString():String {			return "being " + piece_type() + " " + get_id() + " at " + point;		}		/* ***************** SPEED ****************** */		protected var _max_speed=3;// definately override. 		protected var _speed=0;		public function set speed(n:Number):void {			_speed=Math.max(0,Math.min(_max_speed,n));		}		public function get speed():Number {			return _speed;		}		public function top_speed():Number {			return _max_speed;		}		/* ***************** MOVE ****************** */		public function move_random(speed) {			if (moving()) {				trace(" ! ----------- DOUBLE MOVING ------------ ");				return;			}			if (! speed) {				speed=top_speed();			}			var dests:Vector.<Point_ij>=point.can_go_points(this);			if (! dests.length) {				trace("can't move " + this + ": no can go points.");				return;			}			trace(this + " can to to "+ dests);			var dest_point:Point_ij = dests[(int)(Math.random() * dests.length)];			//trace(this + " going to " + dest_point);			move_to(dest_point, speed, true);		}		protected var _destinations:Array = new Array();		public function move_to(p: Point_ij, speed: Number = 0, directly: Boolean = true) {			if (! speed) {				speed=_max_speed;			}			var target:Destination=new Destination(p,speed,this);			if (directly) {				_destinations=new Array(target);			} else {				_destinations.push(target);			}		}		private var _last_move:int=-1;		public function moving():Boolean {			return _destinations.length ? true : false;		}		public function move(t:int) {			if ((t == _last_move) || (!moving())) {// insulation against double-moves in same time. 				return;			}			var d:Destination=_destinations[0];			d.move();			_last_move=t;		}		/**		in almost all cases, the destination to be removed		will be the first one in the queue, so this 		shift and check method should be the most efficient. 		*/		public function end_move(d:Destination) {			point=d.target;			_clear_destination(d);					}				private function _clear_destination(d:Destination) {			var found:Boolean=false;			var dd_array: Array = new Array();			var dd:Destination;			do {				dd=_destinations.shift();				if (dd.get_id()==d.get_id()) {					found=true;				} else {					dd_array.push(dd);				}			} while ((!found) && _destinations.length);			if (dd_array.length) {				_destinations=dd_array.concat(_destinations);			}		}				override public function set point(p: Point_ij):void {			var old_point: Point_ij = point;			old_point.remove_being(this);			p.add_being(this);		}				/* ***************** IGNORE_BLOCK **************** */		/* 		override to selectively let beings pass through blocks. 		*/				public function ignore_block(b: Move_block) {						return false;		}	}}