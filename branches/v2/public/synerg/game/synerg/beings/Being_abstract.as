package game.synerg.beings{	import game.synerg.tiles.Tile_abstract;	import game.synerg.beings.Destination;	import flash.geom.Point;	import game.synerg.tiles.Wall;	import game.synerg.buttons.*;	import game.synerg.PointVector;	import game.Game;	import flash.display.MovieClip;	import Synerg;	public class Being_abstract extends Tile_abstract {		public function update(t:int):void {			// override this to motivate beings ! 		}		override public function toString():String {			return "being " + piece_type() + " " + get_id() + " at " + ij_string();		}		public function ij_string(){			var p = as_ij_point();			return "(i: " + p.x + ", j: " + p.y + ")";		}		/* ***************** SPEED ****************** */		protected var _max_speed=3;// definately override. 		protected var _speed=0;		public function set_speed(n:Number):void {			_speed=Math.max(0,Math.min(_max_speed,n));		}		public function get_speed():Number {			return _speed;		}		public function top_speed():Number {			return _max_speed;		}		/* ***************** MOVE ****************** */		public function as_ij_point():Point {			return new Point(get_i(), get_j());		}		public function as_xy_point():Point {			return new Point(x, y);		}		public static var VECTORS:Vector.<PointVector>=Vector.<PointVector>([new PointVector(-1,0, "W"),new PointVector(0,-1, "S"),		new PointVector(0,1, "E"),new PointVector(1,0, "N")]);		public function move_random(speed) {			if (moving()) {				trace(" ! ----------- DOUBLE MOVING ------------ ");				return;			}			if (! speed) {				speed=top_speed();			}			var dests:Vector.<PointVector>=possible_dests();			if (! dests.length) {				return;			}			var g:Game=Synerg.game();			var bldg_layer:MovieClip=g.get_layer('buildings');			for (var iter = 0; iter < dests.length; ++iter) {				var pv:PointVector=dests[iter];				var l:Look=new Look(x,y,pv.compass);				bldg_layer.addChild(l);			}			trace(this + " possible dests: " + dests);			var dest_point:Point = dests[(int)(Math.random() * dests.length)];			trace(this + " going to " + dest_point);			move_to(dest_point.x, dest_point.y, speed, true);		}		private function possible_dests():Vector.<PointVector> {			var dests:Vector.<PointVector> = new Vector.<PointVector>();			var p:Point=as_ij_point();			for (var index = 0; index < VECTORS.length; ++index) {				var dest_point:PointVector=VECTORS[index].addpv(p);				if ((!dest_point.equals(p)) && can_go(dest_point)) {					dests.push(dest_point);				}			}			return dests;		}		/* overload method to enforce terrain restrictions. */		public function can_go(go_to) {			var from_pt:Point=as_ij_point();			var d:String = "can_go " + this + " to " + go_to;						if (go_to.x!=Synerg.clamp_i(go_to.x)) {				trace (d + " Clamped(X)");				return false;			}			if (go_to.y!=Synerg.clamp_j(go_to.y)) {				trace (d + " Clamped(Y)");				return false;			}			var walls:Array=Synerg.wall_map.items();			for (var w_index = 0; w_index < walls.length; ++w_index) {				var wall:Wall=walls[w_index];				if (wall.blocks(go_to,from_pt)) {										trace(d + " blocked (" + wall + ")");										var g:Game=Synerg.game();					var bldg_layer:MovieClip=g.get_layer('buildings');					var l:Look=new Look_blocked(x,y,PointVector.compass_name(go_to, from_pt));					bldg_layer.addChild(l);					return false;				}			}						trace("Can_go " + this + " to " + go_to + ": GOOD");			return true;		}		/*		override public function random_position(max_iters = 10) {		do {		super.random_position(max_iters);		var p:Point=as_ij_point();		} while (!can_go(p, p));		} */		protected var _destinations:Array = new Array();		public function move_to(new_i: uint, new_j: uint, speed: Number = 0, directly: Boolean = false) {			if (! speed) {				speed=_max_speed;			}			var target:Destination=new Destination(new_i,new_j,speed,this);			if (target.blocked()) {				trace("!---- BLOCK MOVE ATTEMPTED  " + target + " !");				return;			}			var being_x=x;			var being_y=y;			var target_x=target.x;			var target_y=target.y;			var di=new_i-get_i();			var dj=new_j-get_j();			if (directly&&_destinations.length) {				_destinations=new Array(target);			} else {				_destinations.push(target);			}		}		private var _last_move:int=-1;		public function moving():Boolean {			return _destinations.length ? true : false;		}		public function move(t:int) {			if ((t == _last_move) || (!moving())) {// insulation against double-moves in same time. 				return;			}			var d:Destination=_destinations[0];			d.move();			_last_move=t;		}		/**		in almost all cases, the destination to be removed		will be the first one in the queue, so this 		shift and check method should be the most efficient. 		*/		public function end_move(d:Destination) {			var found:Boolean=false;			var dd_array: Array = new Array();			var dd:Destination;			do {				dd=_destinations.shift();				if (dd.get_id()==d.get_id()) {					found=true;				} else {					dd_array.push(dd);				}			} while ((!found) && _destinations.length);			set_i(d.get_i());			set_j(d.get_j());			if (dd_array.length) {				_destinations=dd_array.concat(_destinations);			}		}	}}