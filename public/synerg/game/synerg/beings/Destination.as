package game.synerg.beings{	import game.synerg.beings.Being_abstract;	import game.*;	import flash.geom.Point;	import Synerg;	import game.synerg.tiles.*;	class Destination implements ID_element {		private var _id:uint=0;		public function Destination(p: Point_ij, pSpeed, b: Being_abstract) {			target=p;			being=b;			speed=pSpeed;			set_id(++Destination._next_dest_id);			//trace("new Destionation: " + this);		}		public function is_not_me(d: Destination) {			return d === this ? true : false;		}		public function toString() {			var out:String="Destination for "+being+" to ij= "+target+"; xy= "+target.xy_point;			return out;		}		/* ************** POINTS  ****************** */		private var _target:Point_ij;		public function set target(p: Point_ij) {			_target=p;		}				public function get i(){ return target.i; } 		public function get j(): int { return target.j; }		public function get target() {			return _target;		}		/* ************** MOVEMENT  ****************** */		public function arrived():Boolean {			var b:Being_abstract=being;			var s:Number=speed;			var out:Boolean=is_about(b.x,target.xy_point.x,s)			&&is_about(b.y,target.xy_point.y,s)?true:false;			return out;		}		public function move():void {			var b:Being_abstract=being;			if (arrived()) {// arrived notes approximate matches -- sync to exact target				reset_target();				b.end_move(this);			} else {				var bp:Point=being.point.xy_point;				var tp:Point=target.xy_point;				var d:Number=Point.distance(bp,tp);				var s:Number=speed;				//var ir = i ? (tp.x / i) : 0;				//var jr = j ? (tp.y / j) : 0;				//trace ("Destination::move() -- moving " + b + " towards " + tp);				//trace(tp + ": ir = " +  ir + ", jr = " + jr);				var ratio=Math.min(1,s/d);				var new_bp:Point=Point.interpolate(tp,bp,ratio);				//trace(" -- ratio: " + ratio + ", new point = " + new_bp);				b.x=new_bp.x;				b.y=new_bp.y;			}		}		/*		returns angle between the sprite and its destination point 		*/		public function motion_angle():Number {			var b=being;			var dx=target.xy_point.x-b.x;			var dy=target.xy_point.y-b.y;			if (dx) {				var tan=dy/dx;				return Math.atan(tan);			} else if (dy > 0) {				return Math.PI/2;			} else if (dy < 0) {				return (3 * Math.PI) / 2;			} else {				return 0;			}		}		private function is_about(a: Number, b: Number, slop: Number = 1):Boolean {			if (Math.abs(a-b)<=slop) {				return true;			} else {				return false;			}		}		/* ********* LOCATION ************ */		private function reset_target() {			var b:Being_abstract=being;			b.x=target.xy_point.x+b.nudge_x;			b.y=target.xy_point.y+b.nudge_y;		}		private var _speed:uint=0;		public function set speed(n:uint):void {			var b:Being_abstract=being;			if (! b) {				throw new Error("destination::set_speed() -- no being for dest");			}			_speed=Math.max(0,Math.min(b.top_speed(),n));		}		public function get speed():uint {			return _speed;		}		/* *************** BEING **************** */		private var _being:Being_abstract;		public function set being(b: Being_abstract) {			_being=b;		}		public function get being() {			return _being;		}		public function get_id():uint {			return _id;		}		public function set_id(id: uint) {			_id=id;		}		private static var _next_dest_id:uint=0;	}}