package game.synerg.tiles{	import flash.geom.Point;	import flash.display.MovieClip;	import Synerg;	import flash.events.Event;	import flash.ui.Mouse;	import flash.events.MouseEvent;	import game.ID_element;	import game.synerg.tiles.Tile_abstract;	import game.synerg.beings.Cowboy;	import game.synerg.Map;	/*	This is an "Abstracty class" for Wall_vertical and Wall_horizontal. 	*/	public class Wall extends Tile_abstract {		public function Wall() {			set_id(Synerg.new_id());			set_map(Synerg.wall_map);		}				override public function toString(): String {			return 'Wall between ' + _p1 + ' and ' + _p2;		}		/**		 * The current blocks method presumes no diagonal movement.		 */		public function blocks(from_point: Point, to_point: Point) {			//trace('wall: comparing points ' + from_point + ' and ' + to_point + ' to ' + this);			if (pe(_p1, from_point)) {				if (pe(_p2, to_point)) {					return true;				} else {					return false;				}			} else if (pe(_p1, to_point)) {				if (pe(_p2, from_point)) {					return true;				} else {					return false;				}			} else {				return false;			}		}		private function pe(p1: Point, p2: Point): Boolean {			if (int(p1.x) != int(p2.x)) return false;			if (int(p1.y) != int(p2.y)) return false;			return true;		}		protected function _init(i1, j1, i2, j2) {			_p1=new Point(i1,j1);			_p2=new Point(i2,j2);			set_ij(i1, j1);		}		private var _p1:Point;		private var _p2:Point;				public function p1_ij(): Point_ij{			return Point_ij.point(_p1.x, _p1.y);		}				public function p2.ij():Point_ij {			return Point_ij.point(_p2.x, p2.y);		}		/** for convenience, not checking for overlapping walls */		override public function place():void {			var m:Map=get_map();			m.add_tile(this);			this.status = "placed"			;		}	}}