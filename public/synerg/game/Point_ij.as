package game{	import flash.geom.Point;	import flash.utils.Dictionary;	import de.polygonal.ds.*;	/*	The Point_ij is intended to reflect a grid point on the game board.	It is oriented towards pathfinding and registering blocks. 	It is possible to create "one way blocks"  as in, doors with locks on one side or cliffs. 		board points are kept in a 2d array -- to retrieve board points, use the static point(i,j) method. 	You can create a point that is not on the board thorugh this method but an "unregistered" point will be created. 	*/	public class Point_ij extends Point {		public function Point_ij(i, j) {			set_ij(i, j);		}		public function as_point() {			return new Point(i * Point_ij_test.BOARD_RES, j * Point_ij_test.BOARD_RES);		}		/* **************** I, J Coordinates **************** */		public function get i():int {			return x;		}		public function set i(i):void {			x=int(i);			set_value();		}		public function get j():int {			return y;		}		public function set j(j):void {			y=int(j);			set_value();		}		public function set_ij(i, j) {			x=int(i);			y=int(j);			set_value();		}		private var _value:int;		private var _on_board:Boolean;		public function on_board() {			return _on_board;		}		private function set_value():void {			_on_board=Point_ij_test.on_board(x,y)?true:false;		}		public function value():int {			return _value;		}		/* **************** POINT REGISTRY ******************** */		private static var _points:Array2;		private static function _init_points() {			var iter=0;			_points=new Array2(Point_ij_test.BOARD_SIZE,Point_ij_test.BOARD_SIZE);			for (var i_iter = 0; i_iter < Point_ij_test.BOARD_SIZE; ++i_iter) {				for (var j_iter = 0; j_iter < Point_ij_test.BOARD_SIZE; ++j_iter) {					var pt:Point_ij=new Point_ij(i_iter,j_iter);					_points.set(i_iter, j_iter, pt);				}			}		}		public static function get points():Array2 {			if (! _points) {				_init_points();			}			return _points;		}		public static function point(i: int, j: int, spawn_off_board: Boolean = false):Point_ij {			if (! Point_ij_test.on_board(i,j)) {				return spawn_off_board ? new Point_ij(i, j) : null;			} else {				return points.get(i, j);			}		}		public function ijadd(p: Point_ij, spawn_point = false):Point_ij {			var s_i=i+p.i;			var s_j=j+p.j;			return point(s_i,s_j, spawn_point);		}		/* *********** BLOCKING ************** */		public var _can_go:Vector.<Boolean>;		/* can_go is a colleciton of boolean gates to movement along		compass directions indicated by constants below. */		public function can_go_angles():String {			var a:String='';			for (var ii = 0; ii < can_go.length; ++ii) {				if (can_go[ii]) {					a+=' '+ii;				}			}			return a;		}		public function get can_go():Vector.<Boolean> {			if (! _can_go) {				_can_go=new Vector.<Boolean>(8,true);				for (var iter = 0; iter < 8; ++iter) {					var vect:Point_ij=Point_ij.COMPASS_OFFSETS[iter];					var ij:Point_ij=ijadd(vect);					if (! ij) {// point off board						_can_go[iter]=false;					} else {						_can_go[iter]=true;					}				}			}			return _can_go;		}		public static function block_between(p1: Point_ij, p2:Point_ij) {			if (! p1.next_to(p2,true)) {				return;			}			var p1a:uint=uint(p1.point_to_angle(p2,true));						p1.can_go[p1a]=false;			p2.can_go[(p1a + 4) % 8] = false;						p1.can_go[(p1a + 1) %8] = false;			p2.can_go[(p1a + 5) %8] = false;						p1.can_go[(p1a + 7) %8] = false;			p2.can_go[(p1a + 3) %8] = false;						p1.scrub_go_cache();			p2.scrub_go_cache();		}		public static function block_between_ij(i1, j1, i2, j2) {			block_between(point(i1,j1), point(i2, j2));		}		public function next_to(p: Point_ij, not_equal = false) {			if (not_equal&&equals(p)) {				return false;			}			if ( (Math.abs(i - p.i) > 1 )|| (Math.abs(j - p.j) > 1) ) {				return false;			} else {				return true;			}		}		private var _go_cache:Vector.<Point_ij>=null;		public function scrub_go_cache() {			_go_cache=null;		}		public function get can_go_points() {			var go_points:Array=[];			if (_go_cache == null) {				var cg: Vector.<Boolean> = can_go;				for (var iter = 0; iter < cg.length; ++iter) {					if (cg[iter]) {						var paca=point_at_compass_angle(iter);						if (paca) {							go_points.push(paca);						}					}				}				_go_cache = Vector.<Point_ij>(go_points);			}			return _go_cache;		}		/* ************* ANGLES, COMPASS AND VECTOR CONSTANTS ***********/		/* 		returns the angle to the passed point. 		*/		public function point_to_angle(p: Point_ij, as_compass: Boolean = false):Number {			var dx=p.x-i;			var dy=p.y-j;			var dist=Point.distance(this,p);			if (! dist) {				return 0;			}			var angle=Math.acos(dx/dist);			if (dy < 0) angle = 2 * Math.PI - angle;			//@TODO: cache in HashMap						var angle_degree=angle*180/Math.PI;			if (as_compass) {				var compass_angle=int(ANGLE_TO_COMPASS*angle)%8;				return compass_angle;			}			return angle;		}		public function point_at_compass_angle(compass_angle: uint, spawn_point = false) {			return ijadd(COMPASS_OFFSETS[compass_angle], spawn_point);		}		static var ANGLE_TO_COMPASS=4/Math.PI;		static var COMPASS_E=0;		static var COMPASS_SE=1;		static var COMPASS_S=2;		static var COMPASS_SW=3;		static var COMPASS_W=4;		static var COMPASS_NW=5;		static var COMPASS_N=6;		static var COMPASS_NE=7;		private static var _COMPASS_OFFSETS:Vector.<Point_ij>;		public static function get COMPASS_OFFSETS():Vector.<Point_ij> {			if ((! _COMPASS_OFFSETS) || (!_COMPASS_OFFSETS.length)) {				_COMPASS_OFFSETS =  Vector.<Point_ij>([				 new Point_ij(1, 0), new Point_ij(1, 1), 				 new Point_ij(0, 1), new Point_ij(-1, 1), 				 new Point_ij (-1, 0), new Point_ij (-1, -1),				 new Point_ij(0, -1), new Point_ij(1, -1)				 ]);			}			return _COMPASS_OFFSETS;		}	}}